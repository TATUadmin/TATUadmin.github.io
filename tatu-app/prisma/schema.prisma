// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// âœ… DATABASE CONFIGURATION:
// This schema is configured for PostgreSQL (TimescaleDB).
// All Prisma features are optimized for PostgreSQL.
// For enterprise scale recommendations, see ENTERPRISE_TECH_STACK_EVALUATION.md.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  CUSTOMER
  ARTIST
  SHOP_OWNER
  ADMIN
}

enum ShopStatus {
  PENDING
  ACTIVE
  INACTIVE
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum MessagePlatform {
  EMAIL
  INSTAGRAM
  FACEBOOK
  X_TWITTER
  WHATSAPP
  SMS
  TIKTOK
  INTERNAL
}

enum MessageStatus {
  UNREAD
  READ
  ARCHIVED
  DELETED
}

enum CalendarProvider {
  TATU            // Native TATU bookings
  GOOGLE          // Google Calendar
  APPLE           // iCloud Calendar (CalDAV)
  OUTLOOK         // Microsoft Outlook/Office 365
  SQUARE          // Square Appointments
  CALENDLY        // Calendly
  ACUITY          // Acuity Scheduling
  MANUAL          // Manually added by user
  EMAIL_PARSED    // Extracted from email confirmations
  INSTAGRAM       // Booked via Instagram DM
}

enum EventStatus {
  TENTATIVE       // Not confirmed yet
  CONFIRMED       // Client confirmed
  CANCELLED       // Cancelled by client or artist
  NO_SHOW         // Client didn't show up
  COMPLETED       // Appointment finished
  RESCHEDULED     // Moved to different time
}

enum CalendarView {
  DAY
  WEEK
  MONTH
  AGENDA
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  password      String?
  role          UserRole  @default(CUSTOMER)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  profile       Profile?
  artistAtShops ShopsOnArtists[]
  reviews       Review[]
  ownedShops    Shop[]    @relation("ShopOwner")
  portfolioItems PortfolioItem[]
  portfolioCollections PortfolioCollection[]
  comments      Comment[]
  likes         Like[]
  shares        Share[]
  favorites     Favorite[]
  favoriteArtists Favorite[] @relation("FavoriteArtists")

  // Auth
  accounts      Account[]
  sessions      Session[]

  artistAppointments Appointment[] @relation("ArtistAppointments")
  clientAppointments Appointment[] @relation("ClientAppointments")
  services          Service[]

  connectedAccounts ConnectedAccount[]
  unifiedMessages   UnifiedMessage[]
  messageThreads    MessageThread[]
  
  // Calendar relations
  calendars         Calendar[]
  calendarEvents    CalendarEvent[]
  clientEvents      CalendarEvent[] @relation("ClientEvents")
  
  // Payment relations
  visibilityBoosts  VisibilityBoost[]
  artistPayments    Payment[]        @relation("ArtistPayments")
  clientPayments    Payment[]        @relation("ClientPayments")
  artistDonations   Donation[]       @relation("ArtistDonations")
  clientDonations   Donation[]       @relation("ClientDonations")
  
  // Subscription relation
  subscription      Subscription?
  
  // Calendar preferences
  calendarView      CalendarView    @default(WEEK)
  workingHours      Json?           // { monday: { start: "09:00", end: "17:00" }, ... }
  bufferTime        Int             @default(15) // Minutes between appointments
  defaultEventDuration Int          @default(120) // Default 2-hour sessions
}

model Profile {
  id          String    @id @default(cuid())
  bio         String?   @db.Text
  avatar      String?   // URL to avatar image
  phone       String?
  instagram   String?
  website     String?
  location    String?
  specialties String[]  // Array of tattoo styles/specialties
  completedRegistration Boolean @default(false)
  
  // Visibility boost fields
  visibilityBoostActive Boolean @default(false)
  visibilityBoostEndDate DateTime?
  
  // Subscription cache fields (for quick access)
  subscriptionTier SubscriptionTier @default(FREE)
  subscriptionStatus SubscriptionStatus @default(ACTIVE)
  portfolioImageCount Int @default(0) // Track portfolio image usage
  featuredListingActive Boolean @default(false) // Paid featured placement
  featuredListingEndDate DateTime?
  
  // Relations
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Shop {
  id          String      @id @default(cuid())
  name        String
  description String?     @db.Text
  address     String
  city        String
  state       String
  zipCode     String
  phone       String?
  email       String?
  website     String?
  instagram   String?
  status      ShopStatus  @default(PENDING)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  ownerId     String
  owner       User        @relation("ShopOwner", fields: [ownerId], references: [id])
  artists     ShopsOnArtists[]
  reviews     Review[]
  appointments Appointment[]
  services    Service[]
}

// Join table for many-to-many relation between Shop and Artist Users
model ShopsOnArtists {
  shop       Shop     @relation(fields: [shopId], references: [id])
  shopId     String
  artist     User     @relation(fields: [artistId], references: [id])
  artistId   String
  joinedAt   DateTime @default(now())

  @@id([shopId, artistId])
}

model Review {
  id          String    @id @default(cuid())
  rating      Int       @db.SmallInt
  content     String    @db.Text
  images      String[]  // Array of image URLs
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  shopId      String
  shop        Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)
}

model Service {
  id          String   @id @default(cuid())
  name        String
  description String?
  duration    Int      // in minutes
  price       Float
  shopId      String
  shop        Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  artistId    String?
  artist      User?    @relation(fields: [artistId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  appointments Appointment[]

  @@index([shopId])
  @@index([artistId])
}

model Appointment {
  id          String            @id @default(cuid())
  startTime   DateTime
  endTime     DateTime
  status      AppointmentStatus @default(PENDING)
  notes       String?
  shopId      String
  shop        Shop             @relation(fields: [shopId], references: [id], onDelete: Cascade)
  artistId    String
  artist      User             @relation("ArtistAppointments", fields: [artistId], references: [id])
  clientId    String
  client      User             @relation("ClientAppointments", fields: [clientId], references: [id])
  serviceId   String
  service     Service          @relation(fields: [serviceId], references: [id])
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  // Payment relations
  payments    Payment[]
  donations   Donation[]

  @@index([shopId])
  @@index([artistId])
  @@index([clientId])
  @@index([serviceId])
}

// NextAuth Models
model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model PortfolioCollection {
  id          String    @id @default(cuid())
  name        String
  description String?   @db.Text
  coverImage  String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  items       PortfolioItem[]

  @@index([userId])
}

model PortfolioItem {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  imageUrl    String
  tags        String[]
  style       String
  featured    Boolean   @default(false)
  order       Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  collectionId String?
  collection  PortfolioCollection? @relation(fields: [collectionId], references: [id])
  comments    Comment[]
  likes       Like[]
  shares      Share[]
  analytics   Analytics?

  @@index([userId])
  @@index([collectionId])
  @@index([order])
}

model Comment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  itemId      String
  portfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  parentId    String?
  parent      Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies     Comment[] @relation("CommentReplies")

  @@index([userId])
  @@index([itemId])
  @@index([parentId])
}

model Like {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())

  // Relations
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  itemId      String
  portfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId])
  @@index([itemId])
}

model Share {
  id          String    @id @default(cuid())
  platform    String    // e.g., "facebook", "twitter", "instagram", "direct"
  createdAt   DateTime  @default(now())

  // Relations
  userId      String?   // Optional: track who shared if logged in
  user        User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  itemId      String
  portfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([itemId])
  @@index([platform])
}

model Analytics {
  id          String    @id @default(cuid())
  itemId      String    @unique
  portfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  views       Int       @default(0)
  uniqueViews Int       @default(0)
  lastUpdated DateTime  @updatedAt

  // Daily stats
  dailyStats  DailyAnalytics[]

  @@index([itemId])
}

model DailyAnalytics {
  id          String    @id @default(cuid())
  date        DateTime  @db.Date
  views       Int       @default(0)
  uniqueViews Int       @default(0)
  likes       Int       @default(0)
  comments    Int       @default(0)
  shares      Int       @default(0)

  // Relations
  analyticsId String
  analytics   Analytics @relation(fields: [analyticsId], references: [id], onDelete: Cascade)

  @@unique([analyticsId, date])
  @@index([analyticsId])
  @@index([date])
}

model ViewerSession {
  id          String    @id @default(cuid())
  sessionId   String    // Browser session ID or user ID
  itemId      String    // Portfolio item ID
  firstView   DateTime  @default(now())
  lastView    DateTime  @updatedAt

  @@unique([sessionId, itemId])
  @@index([itemId])
  @@index([sessionId])
}

model VerificationToken {
  id         String    @id @default(cuid())
  token      String    @unique
  email      String
  expires    DateTime
  createdAt  DateTime  @default(now())

  @@unique([email, token])
  @@index([email])
}

model ConnectedAccount {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  platform      MessagePlatform
  accountId     String    // Platform-specific account ID
  accessToken   String    // Encrypted access token
  refreshToken  String?   // Encrypted refresh token
  tokenExpiry   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  lastSynced    DateTime?

  @@unique([userId, platform])
  @@index([userId])
}

model UnifiedMessage {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  platform      MessagePlatform
  externalId    String?   // Original message ID from the platform
  sender        String    // Sender email or username
  senderName    String?   // Display name of sender
  subject       String?
  content       String    @db.Text
  status        MessageStatus @default(UNREAD)
  receivedAt    DateTime
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  labels        String[]  // Custom labels/tags for organization
  attachments   MessageAttachment[]
  thread        MessageThread?   @relation(fields: [threadId], references: [id])
  threadId      String?

  @@index([userId])
  @@index([platform])
  @@index([status])
  @@index([receivedAt])
}

model MessageThread {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  subject       String?
  participants  String[]  // List of participant emails/usernames
  lastMessageAt DateTime
  messages      UnifiedMessage[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
  @@index([lastMessageAt])
}

model MessageAttachment {
  id            String    @id @default(cuid())
  messageId     String
  message       UnifiedMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  fileName      String
  fileType      String
  fileSize      Int
  fileUrl       String
  createdAt     DateTime  @default(now())

  @@index([messageId])
}

model Favorite {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  artistId      String
  artist        User      @relation("FavoriteArtists", fields: [artistId], references: [id], onDelete: Cascade)
  createdAt     DateTime  @default(now())

  @@unique([userId, artistId], name: "userId_artistId")
  @@index([userId])
  @@index([artistId])
}

// New Payment Models

enum PaymentStatus {
  PENDING
  HELD
  CAPTURED
  RELEASED
  REFUNDED
  FAILED
  CANCELLED
}

enum PaymentType {
  APPOINTMENT_HOLD
  VISIBILITY_BOOST
  DONATION
}

model Payment {
  id                    String        @id @default(cuid())
  appointmentId         String?
  artistId              String
  clientId              String
  amount                Int           // Amount in cents
  currency              String        @default("usd")
  status                PaymentStatus @default(PENDING)
  type                  PaymentType
  stripePaymentIntentId String?       @unique
  stripeChargeId        String?
  metadata              Json?         // Additional payment data
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  // Relations
  appointment           Appointment?  @relation(fields: [appointmentId], references: [id])
  artist                User          @relation("ArtistPayments", fields: [artistId], references: [id])
  client                User          @relation("ClientPayments", fields: [clientId], references: [id])

  @@index([appointmentId])
  @@index([artistId])
  @@index([clientId])
  @@index([status])
  @@index([type])
}

enum VisibilityBoostStatus {
  ACTIVE
  EXPIRED
  CANCELLED
}

model VisibilityBoost {
  id                    String                @id @default(cuid())
  artistId              String
  amount                Int                   // Amount in cents
  duration              String                // DAILY, WEEKLY, MONTHLY
  durationDays          Int
  startDate             DateTime
  endDate               DateTime
  status                VisibilityBoostStatus @default(ACTIVE)
  stripePaymentIntentId String?               @unique
  metadata              Json?                 // Additional boost data
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  // Relations
  artist                User                  @relation(fields: [artistId], references: [id])

  @@index([artistId])
  @@index([status])
  @@index([endDate])
}

enum DonationStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

// Subscription Enums

enum SubscriptionTier {
  FREE
  PRO
  STUDIO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAST_DUE
  PAUSED
  TRIAL
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model Donation {
  id                    String          @id @default(cuid())
  appointmentId         String
  artistId              String
  clientId              String
  amount                Int             // Amount in cents
  currency              String          @default("usd")
  message               String?         // Optional donation message
  status                DonationStatus  @default(PENDING)
  stripePaymentIntentId String?         @unique
  metadata              Json?           // Additional donation data
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  // Relations
  appointment           Appointment     @relation(fields: [appointmentId], references: [id])
  artist                User            @relation("ArtistDonations", fields: [artistId], references: [id])
  client                User            @relation("ClientDonations", fields: [clientId], references: [id])

  @@index([appointmentId])
  @@index([artistId])
  @@index([clientId])
  @@index([status])
}

// Calendar Models - Unified Calendar Feature

model Calendar {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  name            String          // "Google Calendar", "Square Appointments"
  provider        CalendarProvider
  providerCalendarId String?      // External calendar ID
  accessToken     String?         @db.Text
  refreshToken    String?         @db.Text
  tokenExpiresAt  DateTime?
  syncEnabled     Boolean         @default(true)
  lastSyncedAt    DateTime?
  color           String          @default("#3B82F6") // Hex color for UI
  isDefault       Boolean         @default(false)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  events          CalendarEvent[]
  
  @@unique([userId, provider, providerCalendarId])
  @@index([userId])
}

model CalendarEvent {
  id              String          @id @default(cuid())
  calendarId      String
  calendar        Calendar        @relation(fields: [calendarId], references: [id], onDelete: Cascade)
  userId          String
  user            User            @relation(fields: [userId], references: [id])
  
  // Event details
  title           String
  description     String?         @db.Text
  location        String?
  
  // Timing
  startTime       DateTime
  endTime         DateTime
  allDay          Boolean         @default(false)
  timezone        String          @default("UTC")
  
  // Recurrence
  isRecurring     Boolean         @default(false)
  recurrenceRule  String?         // iCal RRULE format
  recurrenceId    String?         // Links to parent recurring event
  
  // Client information
  clientId        String?
  client          User?           @relation("ClientEvents", fields: [clientId], references: [id])
  clientName      String?         // For non-TATU clients
  clientEmail     String?
  clientPhone     String?
  
  // Booking details (for tattoo appointments)
  serviceType     String?         // "Tattoo Session", "Consultation", "Touch-up"
  estimatedCost   Decimal?        @db.Decimal(10, 2)
  depositPaid     Boolean         @default(false)
  depositAmount   Decimal?        @db.Decimal(10, 2)
  
  // Status and metadata
  status          EventStatus     @default(CONFIRMED)
  color           String?         // Override calendar color
  
  // External sync
  externalId      String?         // ID in external system (Google, Square, etc.)
  externalUrl     String?         // Link to external booking
  lastSyncedAt    DateTime?
  
  // Conflict detection
  hasConflict     Boolean         @default(false)
  conflictWith    String[]        // Array of conflicting event IDs
  
  // Notifications
  reminderSentAt  DateTime?
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  deletedAt       DateTime?       // Soft delete
  
  @@index([userId])
  @@index([calendarId])
  @@index([startTime, endTime])
  @@index([clientId])
  @@index([status])
}

// Subscription Model - Core Revenue Strategy

model Subscription {
  id                    String              @id @default(cuid())
  userId                String              @unique
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Subscription Details
  tier                  SubscriptionTier    @default(FREE)
  status                SubscriptionStatus  @default(ACTIVE)
  billingInterval       BillingInterval     @default(MONTHLY)
  
  // Pricing
  amount                Int                 @default(0) // Amount in cents
  currency              String              @default("usd")
  
  // Stripe Integration
  stripeSubscriptionId  String?             @unique
  stripeCustomerId      String?
  stripePriceId         String?             // Stripe Price ID for the plan
  
  // Billing Dates
  currentPeriodStart    DateTime?
  currentPeriodEnd      DateTime?
  cancelAt              DateTime?           // Scheduled cancellation date
  canceledAt            DateTime?           // Actual cancellation date
  trialStart            DateTime?
  trialEnd              DateTime?
  
  // Metadata
  metadata              Json?               // Additional subscription data
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  @@index([userId])
  @@index([tier])
  @@index([status])
  @@index([currentPeriodEnd])
}
