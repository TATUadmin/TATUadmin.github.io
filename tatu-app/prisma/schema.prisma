generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  User              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Analytics {
  id             String           @id
  itemId         String           @unique
  views          Int              @default(0)
  uniqueViews    Int              @default(0)
  lastUpdated    DateTime
  PortfolioItem  PortfolioItem    @relation(fields: [itemId], references: [id], onDelete: Cascade)
  DailyAnalytics DailyAnalytics[]

  @@index([itemId])
}

model Appointment {
  id                              String            @id
  notes                           String?
  createdAt                       DateTime          @default(now())
  updatedAt                       DateTime
  shopId                          String
  artistId                        String
  clientId                        String
  endTime                         DateTime
  serviceId                       String
  startTime                       DateTime
  status                          AppointmentStatus @default(PENDING)
  // Link to CalendarEvent when booking is confirmed
  calendarEventId                 String?           @unique
  // Payment hold reference
  paymentHoldId                   String?           @unique
  Payment                         Payment?          @relation("AppointmentPaymentHold", fields: [paymentHoldId], references: [id])
  CalendarEvent                   CalendarEvent?    @relation(fields: [calendarEventId], references: [id])
  User_Appointment_artistIdToUser User              @relation("Appointment_artistIdToUser", fields: [artistId], references: [id])
  User_Appointment_clientIdToUser User              @relation("Appointment_clientIdToUser", fields: [clientId], references: [id])
  Service                         Service           @relation(fields: [serviceId], references: [id])
  Shop                            Shop              @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([artistId])
  @@index([clientId])
  @@index([serviceId])
  @@index([shopId])
  @@index([calendarEventId])
  @@index([paymentHoldId])
}

model Comment {
  id            String        @id
  content       String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime
  userId        String
  itemId        String
  parentId      String?
  PortfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  Comment       Comment?      @relation("CommentToComment", fields: [parentId], references: [id], onDelete: Cascade)
  other_Comment Comment[]     @relation("CommentToComment")
  User          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([itemId])
  @@index([parentId])
  @@index([userId])
}

model ConnectedAccount {
  id           String          @id
  userId       String
  platform     MessagePlatform
  accountId    String
  accessToken  String
  refreshToken String?
  tokenExpiry  DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime
  lastSynced   DateTime?
  User         User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform])
  @@index([userId])
}

model DailyAnalytics {
  id          String    @id
  date        DateTime  @db.Date
  views       Int       @default(0)
  uniqueViews Int       @default(0)
  likes       Int       @default(0)
  comments    Int       @default(0)
  shares      Int       @default(0)
  analyticsId String
  Analytics   Analytics @relation(fields: [analyticsId], references: [id], onDelete: Cascade)

  @@unique([analyticsId, date])
  @@index([analyticsId])
  @@index([date])
}

model Like {
  id            String        @id
  createdAt     DateTime      @default(now())
  userId        String
  itemId        String
  PortfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  User          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([itemId])
  @@index([userId])
}

model MessageAttachment {
  id             String         @id
  messageId      String
  fileName       String
  fileType       String
  fileSize       Int
  fileUrl        String
  createdAt      DateTime       @default(now())
  UnifiedMessage UnifiedMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@index([messageId])
}

model MessageThread {
  id             String           @id
  userId         String
  subject        String?
  participants   String[]
  lastMessageAt  DateTime
  createdAt      DateTime         @default(now())
  updatedAt      DateTime
  User           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  UnifiedMessage UnifiedMessage[]

  @@index([lastMessageAt])
  @@index([userId])
}

model PortfolioCollection {
  id            String          @id
  name          String
  description   String?
  coverImage    String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime
  userId        String
  User          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  PortfolioItem PortfolioItem[]

  @@index([userId])
}

model PortfolioItem {
  id                  String               @id
  title               String
  description         String?
  imageUrl            String
  tags                String[]
  style               String
  featured            Boolean              @default(false)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime
  userId              String
  collectionId        String?
  order               Int                  @default(0)
  Analytics           Analytics?
  Comment             Comment[]
  Like                Like[]
  PortfolioCollection PortfolioCollection? @relation(fields: [collectionId], references: [id])
  User                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  Share               Share[]

  @@index([collectionId])
  @@index([order])
  @@index([userId])
}

model ArtistProfile {
  id                     String    @id
  bio                    String?
  avatar                 String?
  phone                  String?
  instagram              String?
  website                String?
  location               String?
  // Location fields for privacy and booking
  latitude               Float?
  longitude              Float?
  locationRadius         Float?    @default(500) // Radius in feet for privacy (~500ft default)
  actualAddress          String?   // Full address only shown after booking confirmation
  age                    Int?
  specialties            String[]
  userId                 String    @unique
  completedRegistration  Boolean   @default(false)
  // Instagram OAuth fields (same as CustomerProfile)
  instagramHandle        String?   // Instagram username
  instagramAccessToken   String?   // OAuth token for Instagram API
  instagramTokenExpiry   DateTime? // Token expiration date
  instagramLinked        Boolean   @default(false) // Whether Instagram is connected
  // Subscription fields (artists only)
  subscriptionTier       String? // FREE, PRO, STUDIO
  subscriptionStatus     String? // ACTIVE, CANCELLED, EXPIRED
  portfolioImageCount    Int       @default(0)
  featuredListingActive  Boolean   @default(false)
  visibilityBoostActive  Boolean   @default(false)
  visibilityBoostEndDate DateTime?
  User                   User      @relation("ArtistProfile", fields: [userId], references: [id], onDelete: Cascade)
}

model CustomerProfile {
  id                    String   @id
  avatar                String?
  phone                 String?
  bio                   String?  // Short bio for customer profile
  userId                String   @unique
  completedRegistration Boolean  @default(false)
  // Customer preferences
  preferredStyles       String[] // Tattoo styles they're interested in
  locationPreferences   String? // Preferred location/city
  // Instagram integration
  instagramHandle       String? // Instagram username
  instagramAccessToken  String? // OAuth token for Instagram API
  instagramTokenExpiry  DateTime? // Token expiration
  instagramLinked       Boolean  @default(false) // Whether Instagram is connected
  User                  User     @relation("CustomerProfile", fields: [userId], references: [id], onDelete: Cascade)
}

model Subscription {
  id                   String    @id
  userId               String    @unique
  tier                 String // FREE, PRO, STUDIO
  status               String // ACTIVE, CANCELLED, EXPIRED, TRIAL
  billingInterval      String // MONTHLY, YEARLY
  amount               Float
  stripeCustomerId     String?
  stripeSubscriptionId String?
  stripePriceId        String?
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean   @default(false)
  trialStart           DateTime?
  trialEnd             DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  User                 User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

model Review {
  id        String   @id
  rating    Int      @db.SmallInt
  content   String
  images    String[]
  createdAt DateTime @default(now())
  updatedAt DateTime
  userId    String
  shopId    String
  Shop      Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Payment {
  id                    String            @id @default(cuid())
  appointmentId         String?
  artistId              String
  clientId              String
  amount                Int               // Amount in cents
  currency              String            @default("usd")
  platformFee           Int               // Platform fee in cents
  artistAmount          Int               // Amount to artist in cents
  type                  PaymentType       @default(FULL_PAYMENT)
  status                PaymentStatus     @default(PENDING)
  description           String?
  stripePaymentId       String?           @unique // Stripe PaymentIntent ID
  stripeSessionId       String?           @unique // Stripe Checkout Session ID
  metadata              Json?
  completedAt           DateTime?
  createdAt             DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  // Relations
  Appointment           Appointment?      @relation("AppointmentPaymentHold")
  User_Payment_artistId User              @relation("Payment_artistId", fields: [artistId], references: [id])
  User_Payment_clientId User              @relation("Payment_clientId", fields: [clientId], references: [id])

  @@index([appointmentId])
  @@index([artistId])
  @@index([clientId])
  @@index([status])
  @@index([stripePaymentId])
  @@index([stripeSessionId])
}

model Donation {
  id                    String            @id @default(cuid())
  appointmentId         String
  artistId              String
  clientId              String
  amount                Int               // Amount in cents
  currency              String            @default("usd")
  message               String?
  status                DonationStatus    @default(PENDING)
  stripePaymentIntentId String?           @unique
  metadata              Json?
  createdAt             DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  // Relations
  User_Donation_artistId User             @relation("Donation_artistId", fields: [artistId], references: [id])
  User_Donation_clientId User             @relation("Donation_clientId", fields: [clientId], references: [id])

  @@index([appointmentId])
  @@index([artistId])
  @@index([clientId])
  @@index([status])
  @@index([stripePaymentIntentId])
}

model Service {
  id          String        @id
  name        String
  description String?
  duration    Int
  price       Float
  shopId      String
  artistId    String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime
  Appointment Appointment[]
  User        User?         @relation(fields: [artistId], references: [id])
  Shop        Shop          @relation(fields: [shopId], references: [id], onDelete: Cascade)

  @@index([artistId])
  @@index([shopId])
}

model Session {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  User         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Share {
  id            String        @id
  platform      String
  createdAt     DateTime      @default(now())
  userId        String?
  itemId        String
  PortfolioItem PortfolioItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  User          User?         @relation(fields: [userId], references: [id])

  @@index([itemId])
  @@index([platform])
  @@index([userId])
}

model Shop {
  id             String           @id
  name           String
  description    String?
  address        String
  city           String
  state          String
  zipCode        String
  phone          String?
  email          String?
  website        String?
  instagram      String?
  status         ShopStatus       @default(PENDING)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime
  ownerId        String
  Appointment    Appointment[]
  Review         Review[]
  Service        Service[]
  User           User             @relation(fields: [ownerId], references: [id])
  ShopsOnArtists ShopsOnArtists[]
}

model ShopsOnArtists {
  shopId   String
  artistId String
  joinedAt DateTime @default(now())
  User     User     @relation(fields: [artistId], references: [id])
  Shop     Shop     @relation(fields: [shopId], references: [id])

  @@id([shopId, artistId])
}

model UnifiedMessage {
  id                String              @id
  userId            String
  platform          MessagePlatform
  externalId        String?
  sender            String
  senderName        String?
  subject           String?
  content           String
  status            MessageStatus       @default(UNREAD)
  receivedAt        DateTime
  createdAt         DateTime            @default(now())
  updatedAt         DateTime
  labels            String[]
  threadId          String?
  MessageAttachment MessageAttachment[]
  MessageThread     MessageThread?      @relation(fields: [threadId], references: [id])
  User              User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([platform])
  @@index([receivedAt])
  @@index([status])
  @@index([userId])
}

model User {
  id                                     String                @id
  name                                   String?
  email                                  String                @unique
  emailVerified                          DateTime?
  password                               String
  role                                   UserRole              @default(CUSTOMER)
  createdAt                              DateTime              @default(now())
  updatedAt                              DateTime
  Account                                Account[]
  Appointment_Appointment_artistIdToUser Appointment[]         @relation("Appointment_artistIdToUser")
  Appointment_Appointment_clientIdToUser Appointment[]         @relation("Appointment_clientIdToUser")
  Comment                                Comment[]
  ConnectedAccount                       ConnectedAccount[]
  Like                                   Like[]
  MessageThread                          MessageThread[]
  PortfolioCollection                    PortfolioCollection[]
  PortfolioItem                          PortfolioItem[]
  artistProfile                          ArtistProfile?        @relation("ArtistProfile")
  customerProfile                        CustomerProfile?      @relation("CustomerProfile")
  subscription                           Subscription?
  Review                                 Review[]
  Service                                Service[]
  Session                                Session[]
  Share                                  Share[]
  Shop                                   Shop[]
  ShopsOnArtists                         ShopsOnArtists[]
  UnifiedMessage                         UnifiedMessage[]
  Payment_Payment_artistId                Payment[]         @relation("Payment_artistId")
  Payment_Payment_clientId                Payment[]         @relation("Payment_clientId")
  Donation_Donation_artistId              Donation[]        @relation("Donation_artistId")
  Donation_Donation_clientId              Donation[]        @relation("Donation_clientId")

  // Calendar relations
  calendars      Calendar[]
  calendarEvents CalendarEvent[]
  clientEvents   CalendarEvent[] @relation("ClientEvents")

  // Calendar preferences
  calendarView         CalendarView @default(WEEK)
  workingHours         Json?
  bufferTime           Int          @default(15)
  defaultEventDuration Int          @default(120)
}

model VerificationToken {
  id        String   @id
  token     String   @unique
  email     String
  expires   DateTime
  createdAt DateTime @default(now())

  @@unique([email, token])
  @@index([email])
}

model ViewerSession {
  id        String   @id
  sessionId String
  itemId    String
  firstView DateTime @default(now())
  lastView  DateTime

  @@unique([sessionId, itemId])
  @@index([itemId])
  @@index([sessionId])
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum PaymentType {
  CONSULTATION
  DEPOSIT
  FULL_PAYMENT
  REFUND
  APPOINTMENT_HOLD
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
  HELD
}

enum DonationStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum MessagePlatform {
  EMAIL
  INSTAGRAM
  FACEBOOK
  X_TWITTER
  INTERNAL
}

enum MessageStatus {
  UNREAD
  READ
  ARCHIVED
  DELETED
}

enum ShopStatus {
  PENDING
  ACTIVE
  INACTIVE
}

enum CalendarProvider {
  TATU
  GOOGLE
  APPLE
  OUTLOOK
  SQUARE
  CALENDLY
  ACUITY
  MANUAL
  EMAIL_PARSED
  INSTAGRAM
}

enum EventStatus {
  TENTATIVE
  CONFIRMED
  CANCELLED
  NO_SHOW
  COMPLETED
  RESCHEDULED
  PENDING
  DECLINED
  AVAILABLE
  BLOCKED
}

enum EventType {
  MANUAL_BLOCK
  BOOKING
  PERSONAL
  AVAILABILITY
}

enum EventVisibility {
  PRIVATE
  PUBLIC_BUSY
  PUBLIC_AVAILABLE
}

enum CalendarView {
  DAY
  WEEK
  MONTH
  AGENDA
}

enum UserRole {
  CUSTOMER
  ARTIST
  SHOP_OWNER
  ADMIN
}

// Calendar Models - Unified Calendar Feature

model Calendar {
  id                 String           @id @default(cuid())
  userId             String
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  name               String
  provider           CalendarProvider
  providerCalendarId String?
  accessToken        String?          @db.Text
  refreshToken       String?          @db.Text
  tokenExpiresAt     DateTime?
  syncEnabled        Boolean          @default(true)
  lastSyncedAt       DateTime?
  color              String           @default("#3B82F6")
  isDefault          Boolean          @default(false)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  events CalendarEvent[]

  @@unique([userId, provider, providerCalendarId])
  @@index([userId])
}

model CalendarEvent {
  id         String   @id @default(cuid())
  calendarId String
  calendar   Calendar @relation(fields: [calendarId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id])

  // Event details
  title       String
  description String? @db.Text
  location    String?

  // Timing
  startTime DateTime
  endTime   DateTime
  allDay    Boolean  @default(false)
  timezone  String   @default("UTC")

  // Recurrence
  isRecurring    Boolean @default(false)
  recurrenceRule String?
  recurrenceId   String?

  // Client information
  clientId    String?
  client      User?   @relation("ClientEvents", fields: [clientId], references: [id])
  clientName  String?
  clientEmail String?
  clientPhone String?

  // Booking details
  serviceType   String?
  estimatedCost Decimal? @db.Decimal(10, 2)
  depositPaid   Boolean  @default(false)
  depositAmount Decimal? @db.Decimal(10, 2)

  // Status and metadata
  status     EventStatus     @default(CONFIRMED)
  eventType  EventType       @default(BOOKING)
  visibility EventVisibility @default(PRIVATE)
  color      String?

  // External sync
  externalId   String?
  externalUrl  String?
  lastSyncedAt DateTime?

  // Conflict detection
  hasConflict  Boolean  @default(false)
  conflictWith String[]

  // Notifications
  reminderSentAt DateTime?

  // Booking reference (links to Appointment if this is a booking event)
  Appointment Appointment?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([userId])
  @@index([calendarId])
  @@index([startTime, endTime])
  @@index([clientId])
  @@index([status])
}
